#version 430

#define DEPTH_CORRECT 1
#define LINEAR_STEPS 50
#define BINARY_STEPS 25

uniform sampler2D diffuse_map;
uniform sampler2D relief_map;
uniform float scale;
uniform bool show_shadow;
uniform bool show_depth;

in vec3 vertexPosition_cameraspace;
in vec3 LightDirection_tangentspace;
in vec3 EyeDirection_tangentspace;
in vec3 position_tangentspace;
in vec2 pTexCoord;

out vec4 FragColor;

float find_intersection(vec2 A, vec2 B)
{
	float depth = 0.0;

    for(int i = 0; i<LINEAR_STEPS; i++)
    {
        depth += 1.0/LINEAR_STEPS;
        float d = texture2D(relief_map, mix(A, B, depth)).a;
        if(depth>d)
		{
			break;
		}
    }

	float a = depth-(1.0/LINEAR_STEPS);

	for(int i = 0; i<BINARY_STEPS; i++)
    {
        depth = mix(a, depth, 0.5);
        float d = texture2D(relief_map, mix(A, B, depth)).a;

        if(d>depth)
		{
            a = depth;
		}
        else
		{
            depth = depth;
		}
    }
	return depth;
}

void main()
{
    vec2 A = pTexCoord;
    vec3 V = (EyeDirection_tangentspace/-EyeDirection_tangentspace.z) * scale;
    vec2 B = A + V.xy;

    float depth = find_intersection(A, B);

    vec3 P = vec3(mix(A, B, depth), depth);
    vec3 P_tangentSpace = position_tangentspace + (EyeDirection_tangentspace / -EyeDirection_tangentspace.z) * scale * depth;
    vec3 p_to_lightSpace = (position_tangentspace + LightDirection_tangentspace) - P_tangentSpace;

    vec4 diffuseColor = texture2D(diffuse_map, P.xy);
    vec4 color = diffuseColor * vec4(0.2, 0.2, 0.2, 1.0);

    vec3 norm = vec3(texture2D(relief_map, P.xy));
    norm = normalize((norm - 0.5) * 2.0);

    float n_dot_l = max(dot(norm, normalize(p_to_lightSpace)), 0.0);
    if(n_dot_l>0.0)
    {
		if(show_shadow)
		{
			vec3 l_entry = P + (p_to_lightSpace/p_to_lightSpace.z) * scale * depth;
			vec3 l_exit  = l_entry + (p_to_lightSpace/-p_to_lightSpace.z) * scale;
			float l_depth = find_intersection(l_entry.xy, l_exit.xy);

			if(l_depth<depth-0.05) //in shadow
			{
				color += diffuseColor * 0.2 * n_dot_l;
			}
			else
			{
				color += diffuseColor * n_dot_l;
				vec3 H = normalize(p_to_lightSpace + EyeDirection_tangentspace);
				color += vec4(0.5, 0.5, 0.5, 1.0)*pow(max(dot(norm,H),0.0), 64.0);
			}
		}
		else
		{
			color += diffuseColor * n_dot_l;

			vec3 H = normalize(p_to_lightSpace + EyeDirection_tangentspace);
			color += vec4(0.5, 0.5, 0.5, 1.0)*pow(max(dot(norm,H),0.0), 64.0);
		}
	}

#if DEPTH_CORRECT
    const float near = 0.1;
    const float far = 1024.0;
    float p_eye_z = vertexPosition_cameraspace.z + normalize(vertexPosition_cameraspace).z*scale*depth;
    gl_FragDepth = ((-far/(far-near)) * p_eye_z + (-far*near/(far-near)))/ -p_eye_z;
#endif

	if(show_depth)
	{
		FragColor = vec4(depth, depth, depth, 1.0);
	}
	else
	{
		FragColor = color;
	}
}

